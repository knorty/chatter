'use strict';

/** @module where */

const _ = require('lodash');
const parseKey = require('../util/parse-key');
const ops = require('./operations');

/**
 * Stringify a predicate value or value array.
 *
 * @param {Any} value - The value to stringify.
 * @return {String|Array} The processed value.
 */
const stringifyValue = value => {
  if (_.isArray(value)) {
    return value.map(v => v.toString());
  }

  return value.toString();
};

/**
 * Generate a predicate for a query against an ordinary table.
 *
 * @param {Object} condition - A condition object (generated by parseKey).
 * @return {Object} A predicate object.
 */
const tableGenerator = function (condition) {
  // mutators can do things to condition.value, so it has to be in final form
  // before those get applied; and JSON predicates expect strings.
  if (condition.isJSON && condition.value) {
    condition.value = stringifyValue(condition.value);
  }

  if (condition.appended.mutator) {
    condition = condition.appended.mutator(condition);
  } else if (condition.value) {
    condition.params.push(condition.value);
    condition.value = `$${condition.offset}`;
  }

  return {
    predicate: `${condition.lhs} ${condition.appended.operator} ${condition.value}`,
    params: condition.params
  };
};

/**
 * Generate a predicate for a document query.
 *
 * @param {Object} condition - A condition object (generated by parseKey).
 * @param {String} key - The key corresponding to the condition in the criteria object.
 * @param {Array} criteria - The full criteria object for this WHERE clause.
 * @return {Object} A predicate object.
 */
const docGenerator = function (condition, key, criteria) {
  if (_.isArray(condition.value) && _.isPlainObject(condition.value[0])) {
    /*
     * Contains queries, part one: array of objects
     *
     * Contains queries using the @> operator can take advantage of a GIN index
     * on JSONB fields. This gives document queries a dramatic performance boost.
     *
     * Here, the criteria {key: [{matchMe: true}, ...]} search for a
     * corresponding document {key: [..., {matchMe: true}, ...]}. At least one
     * object in the document array must match all conditions of the object(s)
     * in the criteria array. No reason comes to mind to use more than one
     * object in the criteria array; they are effectively merged.
    */
    condition.lhs = condition.path;
    condition.appended.operator = '@>';
    condition.params.push(JSON.stringify(_.pick(criteria, [key])));
    condition.value = `$${condition.offset}`;
  } else if (
    condition.appended.operator === '=' &&
    condition.jsonElements.length === 1 &&
    !_.isArray(condition.value)
  ) {
    /*
     * Contains queries, part two: shallow equality, with a key at the top
     * level of the document body. This is probably the most common situation
     * for document criteria in vivo. Like the array at key above, criteria
     * with a value at key are matched against candidate documents which must
     * have the same value at key to be included.
     */
    const param = _.set({}, condition.jsonElements[0], condition.value);

    condition.lhs = condition.path;
    condition.appended.operator = '@>';
    condition.params.push(JSON.stringify(param));
    condition.value = `$${condition.offset}`;
  } else if (condition.appended.operator !== 'IS' && condition.appended.operator !== 'IS NOT') {
    /*
     * We're querying a key on the document body! `IS` operations need no
     * further treatment. Comparisons use an as-text operator, so we need to
     * convert the value coming out of the JSON/JSONB field to the correct type
     * first.
     */
    let cast = '';

    if (_.isBoolean(condition.value)) {
      cast = '::boolean';
    } else if (_.isNumber(condition.value)) {
      cast = '::decimal';
    } else if (_.isDate(condition.value)) {
      cast = '::timestamptz';
      condition.params.push(condition.value);
      condition.value = `$${condition.offset}`;
    } else if (condition.appended.mutator) {
      condition = condition.appended.mutator(condition);
    } else {
      condition.params.push(stringifyValue(condition.value));
      condition.value = `$${condition.offset}`;
    }

    condition.lhs = `(${condition.lhs})${cast || ''}`;
  }

  return {
    predicate: `${condition.lhs} ${condition.appended.operator} ${condition.value}`,
    params: condition.params
  };
};

/**
 * Build a disjunction (logical OR).
 *
 * @param {Array} conditions - An array of nested criteria objects (relation
 * level). Individual objects will be arrayified, so an 'or' key can work with
 * a single object.
 * @param {Entity} source - The relation being targeted.
 * @param {Number} offset - Offset prepared statement parameter ordinals.
 * @param {Boolean} isDocument - True to target fields in a document body.
 * @return {Object} A disjunction node.
 */
const generateDisjunction = (conditions, source, offset, isDocument) => {
  return _.reduce(conditions, (disjunction, subconditions) => {
    // each member of an 'or' array is itself a conjunction, so build it and
    // integrate it into the disjunction predicate structure
    /* eslint-disable no-use-before-define */
    const conjunction = generateConjunction(subconditions, source, disjunction.offset + disjunction.params.length, isDocument);
    /* eslint-enable no-use-before-define */

    disjunction.params = disjunction.params.concat(conjunction.params);
    disjunction.predicates.push(`(${conjunction.predicates.join(' AND ')})`);

    return disjunction;
  }, {
    params: [],
    predicates: [],
    offset
  });
};

/**
 * Build an inner conjunction (logical OR).
 *
 * @param {Array} conditions - An array of nested criteria objects (relation
 * level). Individual objects will be arrayified, so an 'and' key can work with
 * a single object.
 * @param {Entity} source - The relation being targeted.
 * @param {Number} offset - Offset prepared statement parameter ordinals.
 * @param {Boolean} isDocument - True to target fields in a document body.
 * @return {Object} A nested conjunction node.
 */
const generateInnerConjunction = (conditions, source, offset, isDocument) => {
  return _.reduce(conditions, (conjunction, subconditions) => {
    // each member of an 'and' array is itself a conjunction, so build it and
    // integrate it into the conjunction predicate structure
    /* eslint-disable no-use-before-define */
    const innerConjunction = generateConjunction(subconditions, source, conjunction.offset + conjunction.params.length, isDocument);
    /* eslint-enable no-use-before-define */

    conjunction.params = conjunction.params.concat(innerConjunction.params);
    conjunction.predicates.push(`(${innerConjunction.predicates.join(' AND ')})`);

    return conjunction;
  }, {
    params: [],
    predicates: [],
    offset
  });
};

/**
 * Build a conjunction (logical AND).
 *
 * @param {Object} criteria - A (sub)-criteria object specifying predicates
 * for a single relation.
 * @param {Entity} source - The relation being targeted.
 * @param {Number} offset - Offset prepared statement parameter ordinals
 * @param {Boolean} isDocument - True to target fields in a document body.
 * @return {Object} A conjunction node.
 */
const generateConjunction = (criteria, source, offset, isDocument) => {
  return _.reduce(criteria, (conjunction, value, key) => {
    if (key === 'or') {
      const disjunction = generateDisjunction(value, source, conjunction.offset + conjunction.params.length, isDocument);

      conjunction.params = conjunction.params.concat(disjunction.params);
      conjunction.predicates.push(`(${disjunction.predicates.join(' OR ')})`);

      return conjunction;
    } else if (key === 'and') {
      const inner_conjunction = generateInnerConjunction(value, source, conjunction.offset + conjunction.params.length, isDocument);

      conjunction.params = conjunction.params.concat(inner_conjunction.params);
      conjunction.predicates.push(`(${inner_conjunction.predicates.join(' AND ')})`);

      return conjunction;
    }

    const condition = parseKey.withAppendix(
      isDocument ? `body.${key}` : key,
      source,
      ops,
      value,
      conjunction.offset + conjunction.params.length + 1
    );

    const generator = exports[isDocument ? 'docGenerator' : 'tableGenerator'];
    const result = generator(condition, key, criteria);

    conjunction.predicates.push(result.predicate);

    if (result.params) {
      conjunction.params = conjunction.params.concat(result.params);
    }

    return conjunction;
  }, {
    params: [],
    predicates: [],
    offset: offset || 0
  });
};

/**
 * Query conditions generator.
 *
 * @param {Entity} source - The Readable entity for which this query predicate
 * is being generated.
 * @param {Object} criteria - Query criteria mapping column names (optionally
 * including operation eg 'my_field <>') to the parameter values. Predicates
 * generated from a criteria object are joined together with `and`; an `or` key
 * denotes an array of nested criteria objects, the collected predicates from
 * each of which are parenthesized and joined with `or`.
 * @param {Number} [offset=0] - Added to the token index value in the prepared
 * statement (with offset 0, parameters will start $1, $2, $3).
 * @param {Boolean} [isDocument=false] - True to target fields in a document
 * body.
 *
 * @return {Object} An object representing the query conditions. The
 * `conditions` field contains the final SQL string, the `params` field the
 * parameters for the prepared statement, and the `predicates` field the raw
 * predicate mapping.
 */
exports = module.exports = function where (source, criteria, offset = 0, isDocument = false) {
  if (_.isPlainObject(criteria) && _.isEmpty(criteria)) {
    return {
      conditions: 'TRUE',
      params: []
    };
  }

  if (Object.prototype.hasOwnProperty.call(criteria, 'conditions') && Object.prototype.hasOwnProperty.call(criteria, 'params')) {
    if (_.isPlainObject(criteria.where) && !_.isEmpty(criteria.where)) {
      // searchDoc can pass an alternate inner isDocument in the criteria
      const isInnerDocument = Object.prototype.hasOwnProperty.call(criteria, 'isDocument') ? criteria.isDocument : isDocument;
      const subWhere = where(source, criteria.where, criteria.params.length, isInnerDocument);

      return {
        conditions: `${criteria.conditions} AND ${subWhere.conditions}`,
        params: criteria.params.concat(subWhere.params)
      };
    }

    return {
      conditions: criteria.conditions,
      params: criteria.params
    };
  }

  const conjunction = generateConjunction(criteria, source, offset, isDocument);

  return {
    conditions: conjunction.predicates.join(' AND '),
    params: conjunction.params
  };
};

exports.tableGenerator = tableGenerator;
exports.docGenerator = docGenerator;
